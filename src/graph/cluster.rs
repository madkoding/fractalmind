//! Cluster data structures for RAPTOR algorithm.

#![allow(dead_code)]

use std::collections::HashSet;

use uuid::Uuid;

use crate::models::EmbeddingVector;

/// Represents a cluster of semantically similar nodes.
#[derive(Debug, Clone)]
pub struct Cluster {
    /// Unique identifier for the cluster.
    id: String,

    /// IDs of nodes in this cluster.
    member_ids: Vec<String>,

    /// Centroid embedding (average of member embeddings).
    centroid: Option<EmbeddingVector>,

    /// Average internal similarity.
    internal_similarity: f32,

    /// Depth level in the tree (0 = leaf level).
    depth: usize,

    /// Parent cluster ID (if any).
    parent_id: Option<String>,

    /// Child cluster IDs.
    children_ids: Vec<String>,

    /// Summary text for this cluster (generated by LLM).
    summary: Option<String>,
}

impl Cluster {
    /// Creates a new cluster with given members.
    pub fn new(member_ids: Vec<String>) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            member_ids,
            centroid: None,
            internal_similarity: 0.0,
            depth: 0,
            parent_id: None,
            children_ids: Vec::new(),
            summary: None,
        }
    }

    /// Creates a cluster with a specific ID.
    pub fn with_id(id: String, member_ids: Vec<String>) -> Self {
        Self {
            id,
            member_ids,
            centroid: None,
            internal_similarity: 0.0,
            depth: 0,
            parent_id: None,
            children_ids: Vec::new(),
            summary: None,
        }
    }

    /// Gets the cluster ID.
    pub fn id(&self) -> &str {
        &self.id
    }

    /// Gets the member IDs.
    pub fn members(&self) -> &[String] {
        &self.member_ids
    }

    /// Gets the number of members.
    pub fn size(&self) -> usize {
        self.member_ids.len()
    }

    /// Checks if the cluster is empty.
    pub fn is_empty(&self) -> bool {
        self.member_ids.is_empty()
    }

    /// Gets the centroid embedding.
    pub fn centroid(&self) -> Option<&EmbeddingVector> {
        self.centroid.as_ref()
    }

    /// Sets the centroid embedding.
    pub fn set_centroid(&mut self, centroid: EmbeddingVector) {
        self.centroid = Some(centroid);
    }

    /// Gets the internal similarity.
    pub fn internal_similarity(&self) -> f32 {
        self.internal_similarity
    }

    /// Sets the internal similarity.
    pub fn set_internal_similarity(&mut self, similarity: f32) {
        self.internal_similarity = similarity.clamp(0.0, 1.0);
    }

    /// Gets the depth level.
    pub fn depth(&self) -> usize {
        self.depth
    }

    /// Sets the depth level.
    pub fn set_depth(&mut self, depth: usize) {
        self.depth = depth;
    }

    /// Gets the parent cluster ID.
    pub fn parent_id(&self) -> Option<&str> {
        self.parent_id.as_deref()
    }

    /// Sets the parent cluster ID.
    pub fn set_parent(&mut self, parent_id: String) {
        self.parent_id = Some(parent_id);
    }

    /// Gets the child cluster IDs.
    pub fn children(&self) -> &[String] {
        &self.children_ids
    }

    /// Adds a child cluster.
    pub fn add_child(&mut self, child_id: String) {
        if !self.children_ids.contains(&child_id) {
            self.children_ids.push(child_id);
        }
    }

    /// Gets the summary text.
    pub fn summary(&self) -> Option<&str> {
        self.summary.as_deref()
    }

    /// Sets the summary text.
    pub fn set_summary(&mut self, summary: String) {
        self.summary = Some(summary);
    }

    /// Adds a member to the cluster.
    pub fn add_member(&mut self, member_id: String) {
        if !self.member_ids.contains(&member_id) {
            self.member_ids.push(member_id);
        }
    }

    /// Removes a member from the cluster.
    pub fn remove_member(&mut self, member_id: &str) -> bool {
        if let Some(pos) = self.member_ids.iter().position(|id| id == member_id) {
            self.member_ids.remove(pos);
            true
        } else {
            false
        }
    }

    /// Checks if the cluster contains a specific member.
    pub fn contains(&self, member_id: &str) -> bool {
        self.member_ids.iter().any(|id| id == member_id)
    }

    /// Merges another cluster into this one.
    pub fn merge(&mut self, other: &Cluster) {
        let existing: HashSet<_> = self.member_ids.iter().cloned().collect();
        for id in &other.member_ids {
            if !existing.contains(id) {
                self.member_ids.push(id.clone());
            }
        }
        // Invalidate centroid after merge
        self.centroid = None;
    }

    /// Splits the cluster into smaller clusters based on a partition.
    pub fn split(&self, partitions: Vec<Vec<String>>) -> Vec<Cluster> {
        partitions
            .into_iter()
            .filter(|p| !p.is_empty())
            .map(|member_ids| {
                let mut cluster = Cluster::new(member_ids);
                cluster.set_depth(self.depth);
                cluster
            })
            .collect()
    }
}

/// Result of a clustering operation.
#[derive(Debug, Clone)]
pub struct ClusteringResult {
    /// Generated clusters.
    pub clusters: Vec<Cluster>,

    /// Number of iterations performed.
    pub iterations: usize,

    /// Total time taken in milliseconds.
    pub time_ms: u64,

    /// Number of nodes that couldn't be clustered.
    pub orphan_count: usize,
}

impl ClusteringResult {
    /// Creates a new clustering result.
    pub fn new(clusters: Vec<Cluster>, iterations: usize, time_ms: u64) -> Self {
        Self {
            clusters,
            iterations,
            time_ms,
            orphan_count: 0,
        }
    }

    /// Gets the number of clusters.
    pub fn cluster_count(&self) -> usize {
        self.clusters.len()
    }

    /// Gets the total number of nodes across all clusters.
    pub fn total_nodes(&self) -> usize {
        self.clusters.iter().map(|c| c.size()).sum()
    }

    /// Gets the average cluster size.
    pub fn average_size(&self) -> f32 {
        if self.clusters.is_empty() {
            0.0
        } else {
            self.total_nodes() as f32 / self.clusters.len() as f32
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cluster_creation() {
        let members = vec!["node1".to_string(), "node2".to_string()];
        let cluster = Cluster::new(members.clone());

        assert_eq!(cluster.size(), 2);
        assert!(!cluster.is_empty());
        assert!(cluster.contains("node1"));
        assert!(cluster.contains("node2"));
        assert!(!cluster.contains("node3"));
    }

    #[test]
    fn test_cluster_with_id() {
        let cluster = Cluster::with_id("test-id".to_string(), vec!["node1".to_string()]);
        assert_eq!(cluster.id(), "test-id");
    }

    #[test]
    fn test_cluster_add_member() {
        let mut cluster = Cluster::new(vec!["node1".to_string()]);
        cluster.add_member("node2".to_string());

        assert_eq!(cluster.size(), 2);
        assert!(cluster.contains("node2"));

        // Adding duplicate should not increase size
        cluster.add_member("node2".to_string());
        assert_eq!(cluster.size(), 2);
    }

    #[test]
    fn test_cluster_remove_member() {
        let mut cluster = Cluster::new(vec!["node1".to_string(), "node2".to_string()]);

        assert!(cluster.remove_member("node1"));
        assert_eq!(cluster.size(), 1);
        assert!(!cluster.contains("node1"));

        // Removing non-existent member returns false
        assert!(!cluster.remove_member("node3"));
    }

    #[test]
    fn test_cluster_merge() {
        let mut cluster1 = Cluster::new(vec!["node1".to_string(), "node2".to_string()]);
        let cluster2 = Cluster::new(vec!["node2".to_string(), "node3".to_string()]);

        cluster1.merge(&cluster2);

        assert_eq!(cluster1.size(), 3);
        assert!(cluster1.contains("node1"));
        assert!(cluster1.contains("node2"));
        assert!(cluster1.contains("node3"));
    }

    #[test]
    fn test_cluster_split() {
        let cluster = Cluster::new(vec![
            "node1".to_string(),
            "node2".to_string(),
            "node3".to_string(),
        ]);

        let partitions = vec![
            vec!["node1".to_string()],
            vec!["node2".to_string(), "node3".to_string()],
        ];

        let splits = cluster.split(partitions);

        assert_eq!(splits.len(), 2);
        assert_eq!(splits[0].size(), 1);
        assert_eq!(splits[1].size(), 2);
    }

    #[test]
    fn test_cluster_parent_child() {
        let mut parent = Cluster::new(vec![]);
        let child = Cluster::new(vec!["node1".to_string()]);

        parent.add_child(child.id().to_string());
        assert_eq!(parent.children().len(), 1);

        let mut child_cluster = child.clone();
        child_cluster.set_parent(parent.id().to_string());
        assert_eq!(child_cluster.parent_id(), Some(parent.id()));
    }

    #[test]
    fn test_cluster_summary() {
        let mut cluster = Cluster::new(vec!["node1".to_string()]);
        assert!(cluster.summary().is_none());

        cluster.set_summary("This is a summary".to_string());
        assert_eq!(cluster.summary(), Some("This is a summary"));
    }

    #[test]
    fn test_clustering_result() {
        let clusters = vec![
            Cluster::new(vec!["n1".to_string(), "n2".to_string()]),
            Cluster::new(vec!["n3".to_string(), "n4".to_string(), "n5".to_string()]),
        ];

        let result = ClusteringResult::new(clusters, 5, 100);

        assert_eq!(result.cluster_count(), 2);
        assert_eq!(result.total_nodes(), 5);
        assert!((result.average_size() - 2.5).abs() < f32::EPSILON);
        assert_eq!(result.iterations, 5);
        assert_eq!(result.time_ms, 100);
    }

    #[test]
    fn test_empty_clustering_result() {
        let result = ClusteringResult::new(vec![], 0, 0);

        assert_eq!(result.cluster_count(), 0);
        assert_eq!(result.total_nodes(), 0);
        assert!((result.average_size() - 0.0).abs() < f32::EPSILON);
    }
}
